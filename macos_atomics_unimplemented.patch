diff --git a/src/builtins/builtins-typed-array.cc b/src/builtins/builtins-typed-array.cc
index 189d424835a..53053a21fdf 100644
--- a/src/builtins/builtins-typed-array.cc
+++ b/src/builtins/builtins-typed-array.cc
@@ -505,10 +505,14 @@ simdutf::result ArrayBufferSetFromBase64(
   output_length = array_length;
   simdutf::result simd_result;
   if (typed_array->buffer()->is_shared()) {
+#if SIMDUTF_ATOMIC_REF
     simd_result = simdutf::atomic_base64_to_binary_safe(
         reinterpret_cast<const T>(input_vector), input_length,
         reinterpret_cast<char*>(typed_array->DataPtr()), output_length,
         alphabet, last_chunk_handling, /*decode_up_to_bad_char*/ true);
+#else
+  UNIMPLEMENTED();
+#endif
   } else {
     simd_result = simdutf::base64_to_binary_safe(
         reinterpret_cast<const T>(input_vector), input_length,
@@ -826,9 +830,13 @@ BUILTIN(Uint8ArrayPrototypeToBase64) {
 
     size_t simd_result_size;
     if (uint8array->buffer()->is_shared()) {
+#if SIMDUTF_ATOMIC_REF
       simd_result_size = simdutf::atomic_binary_to_base64(
           std::bit_cast<const char*>(uint8array->DataPtr()), length,
           reinterpret_cast<char*>(output->GetChars(no_gc)), alphabet);
+#else
+      UNIMPLEMENTED();
+#endif
     } else {
       simd_result_size = simdutf::binary_to_base64(
           std::bit_cast<const char*>(uint8array->DataPtr()), length,
diff --git a/src/objects/simd.cc b/src/objects/simd.cc
index 0ef570ceb7d..7878a20d478 100644
--- a/src/objects/simd.cc
+++ b/src/objects/simd.cc
@@ -477,22 +477,6 @@ void Uint8ArrayToHexSlow(const char* bytes, size_t length,
   }
 }
 
-void AtomicUint8ArrayToHexSlow(const char* bytes, size_t length,
-                               DirectHandle<SeqOneByteString> string_output) {
-  int index = 0;
-  // std::atomic_ref<T> must not have a const T, see
-  // https://cplusplus.github.io/LWG/issue3508
-  // we instead provide a mutable input, which is ok since we are only reading
-  // from it.
-  char* mutable_bytes = const_cast<char*>(bytes);
-  for (size_t i = 0; i < length; i++) {
-    uint8_t byte =
-        std::atomic_ref<char>(mutable_bytes[i]).load(std::memory_order_relaxed);
-    PerformNibbleToHexAndWriteIntoStringOutPut(byte, index, string_output);
-    index += 2;
-  }
-}
-
 inline uint16_t ByteToHex(uint8_t byte) {
   const uint16_t correction = (('a' - '0' - 10) << 8) + ('a' - '0' - 10);
 #if V8_TARGET_BIG_ENDIAN
@@ -646,7 +630,7 @@ Tagged<Object> Uint8ArrayToHex(const char* bytes, size_t length, bool is_shared,
 #endif
 
   if (is_shared) {
-    AtomicUint8ArrayToHexSlow(bytes, length, string_output);
+    UNIMPLEMENTED();
   } else {
     Uint8ArrayToHexSlow(bytes, length, string_output);
   }
@@ -1083,8 +1067,7 @@ bool ArrayBufferFromHex(const base::Vector<T>& input_vector, bool is_shared,
     result = HandleRemainingHexValues(input_vector, i);
     if (result.has_value()) {
       if (is_shared) {
-        std::atomic_ref<uint8_t>(buffer[index++])
-            .store(result.value(), std::memory_order_relaxed);
+        UNIMPLEMENTED();
       } else {
         buffer[index++] = result.value();
       }
